学习笔记

>
> [1、复杂度](#1)
>
>> [1.1、常见时间复杂度](#1.1)
>
>> [1.2、各种复杂度比较](#1.2)
>
>> [1.3、常用算法复杂度](#1.3)
>
> [2、数组、链表、跳表](#2)
>
>> [2.1、数组](#2.1)
>
>> [2.2、链表](#2.2)
>
>> [2.3、跳表](#2.3)
>
>>
> [3、队列、栈](#3)
>>
> [4、优先队列](#4)
>


<h3 id='1'> 1、复杂度 </h3>


<h4 id='1.1'> 1.1、常见时间复杂度 </h4>

- O(1) 常数复杂度

	- 代码片段 1: 时间复杂度 O(1)

	```
	fmt.Println("hello world")
	```

    - 代码片段 2: 时间复杂度 O(1)

	```
	fmt.Print("hello")
	fmt.Print(" ")
	fmt.Print("world\n")
	```

- O(log(n)) 对数复杂度

	```
	for i:=1; i<n; i=i*2 {
		fmt.Println("hello")
	}
	```


- O(n) 线性时间复杂度
	
	- 代码片段

	```
	for i:=0; i<n; i++ {
		fmt.Println(i)
	}
	```
	
	上面代码执行的次数和 `n` 相关，是线性的，所以是 O(n)

- O(n^2) 平方复杂度
	
	- 代码片段

	```
	for i:=0; i<n; i++ {
	    for j=0; j<m; j++ {
			fmt.Println(i, j)
	    }
	}
	```
	上面代码两层for循环，时间负载度就是 O(m * n) , 即 O(n²)
	

- O(n^3) 立方复杂度

```
for i:=0; i<n; i++ {
    for j=0; j<m; j++ {
        for k=0; k<l; k++ {
			fmt.Println(i, j)
		  }
    }
}
```


- O(k^n) 指数复杂度

	```
	func fib(n int) int {
		if n<2 {
			return n
		}
		
		return fib(n-1) + fib(n-2)
	}
	```
	
由于每一层展开节点数都是上一层的2倍，每个节点计算一次，那么n的话，就是 2^n 次方, 比如4的话就是 8
	
[递归分析](/Users/dkos/Github/goproject/algorithm019/Week_01/image/递归分析.png)

```
                                                4
                                             /     \
                                           /        \
                                         /           \
                                       /              \
                                     /                 \
                                   /                    \
                                 /                       \
                               /                          \
                              /                            \
                             3                                2
                          /    \                             /  \
                        /       \                          /     \
                      /          \                       /        \
                    /             \                    /           \
                  /                \                 /              \
                /                   \              /                 \
              /                      \           /                    \
            2                        1          1                      0
          /   \
       1        0       

```
   

<h4 id='1.2'> 1.2、各种复杂度比较 </h4>

[复杂度对比](/Users/dkos/Github/goproject/algorithm019/Week_01/image/复杂度比较.png)



<h4 id='1.3'> 1.3、常用算法复杂度 </h4>

|算法|时间复杂度|
|---|---|
|二分查找|O(logn)|
|二叉树遍历|O(n)|
|排序矩阵搜索|O(n)|
|归并排序| O(n logn)|
|图遍历| O(n)|


<h3 id='2'> 2、数组、链表、跳表 </h3>

<h4 id='2.1'> 2.1、数组 </h4>

- 内存模型：内存一段连续的空间


```
   +------------------+
 0 |       a          |
   +------------------+
 1 |       b          |
   +------------------+
 2 |       c          |
   +------------------+
 3 |       d          |
   +------------------+
```


- 复杂度：

    - 查询: O(1)
    - 删除: O(n)
    - 插入: O(n)


<h4 id='2.2'> 2.2、链表 </h4>


- 内存模型：一个指向下一个节点的指针和数据组成一个完整节点，彼此连接


```
 +------+     +------+     +------+
 | data |     | data |     | data |
 +------+     +------+     +------+
 | Next +---->+ Next +---->+ Next +
 +------+     +------+     +------+
```


- 复杂度：

    - 查询: O(n)
    - 删除: O(1)
    - 插入: O(1)


> 从数组和链表可以看出，没有一种数据结构是完美的，具体如何使用看场景，增删多用链表，查询多用数组
> 


<h4 id='2.3'> 2.3、跳表 </h4>

链表里面的元素有序, 它对标的是平衡树，二分查找，是一种插入/删除/搜索 都是 O(logn) 的数据结构，

```
 +------+                                            +------+
 |   1  |                                            |  9   |
 +------+                                            +------+                                  第一级
 | Next +------------------------------------------->+ Next |
 +--+---+                                            +--+---+
    |                                                   |
   \|/                                                 \|/
 +------+                  +------+                  +------+                  +------+
 |   1  |                  |  4   |                  |  9   |                  |  11  |
 +------+                  +------+                  +------+                  +------+        第二级
 | Next +----------------->+ Next +----------------->+ Next +----------------->+ Next |
 +--+---+                  +---+--+                  +--+---+                  +---+--+
    |                          |                        |                          |  
   \|/                        \|/                      \|/                        \|/       
 +------+     +------+     +------+     +------+     +------+     +------+     +------+
 |   1  |     |   3  |     |  4   |     |   5  |     |  9   |     |  10  |     |   11 |
 +------+     +------+     +------+     +------+     +------+     +------+     +------+        第三级别
 | Next +---->+ Next +---->+ Next +---->+ Next +---->+ Next +---->+ Next +---->+ Next +
 +------+     +------+     +------+     +------+     +------+     +------+     +------+
```

> 多一维多一份信息


> 空间复杂度 O(n), 用来建立索引

应用： LRU缓存算法、Redis 


<h3 id='3'> 3、队列、栈 </h3>

- 栈：先进后出

比如有序列 [a, b, c, d, e] 依次入栈，则出的顺序为 e, d, c, b, a


```
e-------+   +------------------>e
        |   |
       \|/  |
 |               |
 +---------------+
 |      d        |
 +---------------+
 |      c        |
 +---------------+
 |      b        |
 +---------------+
 |      a        |
 +---------------+
```



- 队列: 先进先出


比如有序列 [a, b, c, d, e] 依次入栈，则出的顺序为 a, b, c, d, e

```

e-------+
        |
       \|/
 |               |
 +---------------+
 |      d        |
 +---------------+
 |      c        |
 +---------------+
 |      b        |
 +---------------+
 |      a        |
 +---------------+
 |      |        |
        |
        +--------------------->a
```


<h3 id='4'> 4、优先队列 </h3>

不遵从先入先出，而是根据优先级，优先级高的先出或者后出，根据实际场景的比较函数

- 插入操作： O(1)

- 取出操作：O(logn)

