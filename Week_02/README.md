学习笔记

> 散列表原理

- hash 函数求键在哈希表中的位置

- 哈希表中存放value，发生碰撞可以用链表等结构解决


> 散列表关键

- hash函数的选择: 好，降低碰撞，坏，多个key碰撞，使得搜索编程链表复杂度 O(n)

- hash表的大小：小则碰撞概率会很高, 大降低碰撞，


> 面试四件套

1. 和面试官把题目分析一遍

2. 找出可能的解，选择最优的<时间和空间复杂度最好>

    - 暴力

3. 写代码

4. 测试

> 树为什么递归？

能递归的，首先是能归纳出固定的单点操作套路，然后看套路是否在所有节点上能适用，

若适用，基本可以递归解决，对于一维递归会带来额外函数栈的开销，同时降低了理解

此时for循环就可以。对于树，它是二维，两个维度for循环操作复杂度高，同时树的节点

相互之间有联系，找到跟才能知道左和右, 需要回归，回归类似函数返回到初始点，然后

再开始, 总结下来两点

- 二维遍历，for 循环复杂度高

- 归纳单元执行后回归需要到另一个维度


> 递归本质

本质是操作系统帮你创建栈空间，系统维护栈，因此可以用手动维护栈来结局
