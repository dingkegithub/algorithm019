学习笔记

> 散列表原理

- hash 函数求键在哈希表中的位置

- 哈希表中存放value，发生碰撞可以用链表等结构解决


> 散列表关键

- hash函数的选择: 好，降低碰撞，坏，多个key碰撞，使得搜索编程链表复杂度 O(n)

- hash表的大小：小则碰撞概率会很高, 大降低碰撞，


> 面试四件套

1. 和面试官把题目分析一遍

2. 找出可能的解，选择最优的<时间和空间复杂度最好>

3. 写代码

4. 测试

> 树为什么递归？

能递归的，首先是能归纳出固定的单点操作套路，然后看套路是否在所有节点上能适用，

若适用，基本可以递归解决，对于一维递归会带来额外函数栈的开销，同时降低了理解

此时for循环就可以。对于树，它是二维，两个维度for循环操作复杂度高，同时树的节点

相互之间有联系，找到跟才能知道左和右, 需要回归，回归类似函数返回到初始点，然后

再开始, 总结下来两点

- 二维遍历，for 循环复杂度高

- 归纳单元执行后回归需要到另一个维度


> 递归本质

本质是操作系统帮你创建栈空间，系统维护栈，因此可以用手动维护栈来解决


> 堆

一般值的是二叉堆，但是不限于二叉，二叉只是效率比较低实现简单的一种堆

其 查找是 O(1)的复杂度，其它操作 log(n), 最坏时复杂度为 O(n), 其中另外

一种实现斐波拉契堆除了删除是 log(n) 其它都是 O(1) 的复杂度

> 堆性质

- 完全二叉树

- 大顶或小顶

> 大顶堆

跟 > 子节点

> 小顶堆

跟 < 子节点

> 堆核心操作

- 插入：尾部插入，向上调整
- 删除：删除后向下调整
- 取极值：根和最后一个元素交换，排除最后一个元素，向上调整

> 图的组成

- 点： 有度的概念， 入度和出度，直白点就是进和出的边数目
- 变：有无方向之分，权重值分，默认1，向就是箭头上的指向，出还是如，无向就是类似线两边都有箭头

可得出一个结论，对于无向图，出度和入度相同

> 图的两种表示法

- 邻接矩阵:

行列表示点，值表示点之间的权重，0表示无相连

```
            0:E
            / |
           /  |
          /   |
         /    |
       1:M    |35
        | \   |
        |  \  |
       2:B  \ |
             \|
             3:L
       

     0  1  2  3
0    0  1  0  1
1    1  0  1  1 
2    0  1  0  0
3    35 1  0  0

```

- 邻接链表

用链表存储，链表直接存储和点有相连的节点

```
            0:E
            / |
           /  |
          /   |
         /    |
       1:M    |35
        | \   |
        |  \  |
       2:B  \ |
             \|
             3:L
       
0 -->1 --> 3:35

1 -->0 -->2 --> 3

2 -->1

3 -->0:35 --> 1

```

> 图遍历 DFS 模板

最大区别就是 visited=set()，因为图有环路，树没有环路，保证节点只被访问一次

```
def dfs(node, visited):
    if node in visited:
        return
    visited.add(node)
    
    for nxt_node in node.children():
        if not nxt_node in visited:
            dfs(nxt_node, visited)
```

> 图的遍历 BFS 模板

```
def BFS(graph, start, end):
    queue = []
    queue.append([start])
    
    visited = set()
    
    while queue:
        node = queue.pop()
        visited.add(node)
        
        process(node)
        
        nodes = generate_related_nodes(node)
        queue.push(nodes)

```
